<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Foursomes — Golftrix</title>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700&display=swap" rel="stylesheet" />
<style>
  :root { --green-1:#007f00; --green-2:#00cc44; }
  body { font-family:'Orbitron',sans-serif; padding:12px; background:#f6f6f6; color:#111; }
  .card {
        background:#fff;
        border-radius:12px;
        padding:12px;
        box-shadow:0 6px 18px rgba(0,0,0,0.06);
        margin-bottom:12px;
        width:100%;
        box-sizing:border-box;
    }

  h1 { margin:0 0 8px 0; color:var(--green-1); }
  label{ font-weight:700; display:block; margin-bottom:6px; }
  select,input[type=number]{ padding:8px; border-radius:8px; border:1px solid #ddd; width:100%; box-sizing:border-box; }
  .row { display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
  .col { flex:1; min-width:200px; }
  button.primary{ background:linear-gradient(90deg,var(--green-1),var(--green-2)); color:#fff; border:0; padding:8px 12px; border-radius:10px; cursor:pointer; font-weight:800; }
  button.ghost{ background:transparent; border:1px solid #ddd; padding:8px 10px; border-radius:8px; cursor:pointer; }
  .pairs-list{ display:flex; gap:8px; flex-wrap:wrap; margin-top:8px; }
  .pair-pill{ padding:8px 10px; border-radius:10px; display:flex; gap:8px; align-items:center; color:#fff; font-weight:800; }
  .badge { width:36px; height:36px; border-radius:50%; display:inline-flex; align-items:center; justify-content:center; background:#000; color:#fff; font-weight:800; border:3px solid transparent; }
  table { width:100%; border-collapse:collapse; margin-top:8px; }
  th,td { padding:6px; border:1px solid #eee; text-align:center; font-size:0.9rem; }
  th.nameCol, td.nameCol { text-align:left; padding-left:10px; }
  .hole-empty { background:#fafafa; color:#999; }
  .score-less { color:green; font-weight:800; }
  .score-more { color:red; font-weight:800; }
  .neutral-bg { background:#f5f5f5; }
  .result-pill { font-weight:900; padding:6px 8px; border-radius:8px; display:inline-block; min-width:56px; text-align:center; }
  .saldo { font-weight:900; font-size:1.1rem; padding:8px; border-radius:8px; display:inline-block; }
  .team-header { display:flex; gap:8px; align-items:center; font-weight:900; }
  .tables-wrap { display:flex; gap:12px; flex-direction:column; }
  @media (min-width:1000px){ .tables-grid{ display:grid; grid-template-columns:1fr 1fr; gap:12px; } }
</style>
</head>
<body>
  <div class="card">
    <h1>Foursomes - Modo Grupo</h1>
    <div class="row">
      <div class="col">
        <label for="priceInput">Precio por pareja (MXN)</label>
        <input type="number" id="priceInput" min="1" step="1" />
      </div>
      <div class="col">
        <label>Seleccionar Jugadores para Pareja</label>
        <div style="display:flex;gap:8px">
          <select id="player1Select"></select>
          <select id="player2Select"></select>
          <button id="addPairBtn" class="primary">Agregar Pareja</button>
        </div>
      </div>
    </div>

    <div style="margin-top:12px;">
      <div style="display:flex; justify-content:space-between; align-items:center;">
        <div><strong>Parejas creadas</strong></div>
        <div>
          <button id="startGameBtn" class="primary">Comenzar Juego</button>
          <button id="refreshBtn" class="ghost">Refrescar</button>
        </div>
      </div>
      <div id="pairsList" class="pairs-list"></div>
    </div>
  </div>

  <div id="gameArea" class="card" style="display:none;">
    <div id="gameHeader" style="display:flex; justify-content:space-between; align-items:center;">
      <div id="gameMeta"></div>
      <div id="miSaldo" class="saldo neutral-bg"></div>
    </div>

    <div id="matchupsContainer" class="tables-wrap"></div>
  </div>

<script>
  function getQueryParam(n){ const u=new URL(location.href); return u.searchParams.get(n); }
</script>

<script type="module">
  let myPair = null;  // <-- global para tu usuario actual

  import { app, db, auth } from './firebase-config.js';
  import { onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";
  import {
    doc, getDoc, setDoc, updateDoc, serverTimestamp,
    collection, query, where, getDocs, addDoc
  } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

  // --- Estado y elementos DOM ---
  const juegoId = getQueryParam('juegoId') || getQueryParam('id') || ('foursomes_' + Date.now());
  // --- Grupo relacionado al juego (se cargará desde doc 'juegos/<juegoId>')
  let grupoId = null;
  const player1Select = document.getElementById('player1Select');
  const player2Select = document.getElementById('player2Select');
  const addPairBtn = document.getElementById('addPairBtn');
  const pairsList = document.getElementById('pairsList');
  const priceInput = document.getElementById('priceInput');
  const startGameBtn = document.getElementById('startGameBtn');
  const refreshBtn = document.getElementById('refreshBtn');
  const gameArea = document.getElementById('gameArea');
  const gameMeta = document.getElementById('gameMeta');
  const matchupsContainer = document.getElementById('matchupsContainer');
  const miSaldoEl = document.getElementById('miSaldo');

  const authInst = auth;
  let currentUser = null;
  onAuthStateChanged(authInst, (user) => {
    if (user) {
      currentUser = user;
      console.log("Usuario logueado:", currentUser.uid);
    } else {
      console.warn("No hay usuario autenticado");
    }
  });


  // Data caches
  let allUsers = []; // { uid, nombre, initials, handicap, gender }
  let tarjetasCache = []; // tarjetas para este juego
  let camposCache = {}; // campoId -> campoData
  let pairs = []; // { id, p1Uid, p2Uid, color }

  // utils
  function randColor() {
    // palette saturada
    const palette = ['#e63946','#ff6b6b','#f97316','#f59e0b','#ffd166','#06d6a0','#118ab2','#3a86ff','#7c4dff','#9d4edd'];
    return palette[Math.floor(Math.random()*palette.length)];
  }
  function initialsFromName(name){
    if(!name) return '';
    const parts = name.split(' ').filter(Boolean);
    if(parts.length===1) return parts[0].slice(0,2).toUpperCase();
    return (parts[0][0]+ (parts[1]?.[0]||'')).toUpperCase();
  }


async function ensureGrupoId() {
  if (grupoId) return grupoId;
  try {
    const jSnap = await getDoc(doc(db, 'juegos', juegoId));
    if (jSnap.exists()) {
      grupoId = jSnap.data()?.grupoId || null;
    }
    return grupoId;
  } catch (e) {
    console.error("Error obteniendo grupoId", e);
    return null;
  }
}
await ensureGrupoId();
await loadUsers();


// ---------------------- FIRESTORE: obtener usuarios disponibles (solo del grupo si existe) ----------------------
async function loadUsers() {
  allUsers = [];
  try {
    if(!grupoId) {
      console.warn("grupoId no definido en loadUsers");
      populateUserSelects(); // vaciar selects por seguridad
      return;
    }

    const gSnap = await getDoc(doc(db, 'grupos', grupoId));
    if (!gSnap.exists()) {
      console.warn("Documento de grupo no existe");
      populateUserSelects(); // vaciar selects
      return;
    }

    const gData = gSnap.data();
    const membersArray = Array.isArray(gData.miembros) ? gData.miembros 
                  : Array.isArray(gData.grupo) ? gData.grupo 
                  : [];

    if(membersArray.length === 0){
    console.warn("No hay miembros en el grupo");
    populateUserSelects();
    return;
    }

    allUsers = await Promise.all(
    membersArray.map(async m => {
        const uid = m.uid || m.id;
        try {
        const userSnap = await getDoc(doc(db, 'users', uid));
        if (userSnap.exists()) {
            const uData = userSnap.data();
            const fullName = `${uData.name || ''} ${uData.lastname || ''}`.trim();
            return {
            id: uid,
            nombre: fullName || 'Sin Nombre',
            initials: initialsFromName(fullName),
            handicap: uData.handicap || 0,
            gender: uData.gender || 'M'
            };
        } else {
            return {
            id: uid,
            nombre: 'Sin Nombre',
            initials: 'SN',
            handicap: 0,
            gender: 'M'
            };
        }
        } catch(e){
        console.error('Error leyendo user', uid, e);
        return {
            id: uid,
            nombre: 'Sin Nombre',
            initials: 'SN',
            handicap: 0,
            gender: 'M'
        };
        }
    })
    );



    console.log("Usuarios cargados del grupo:", allUsers);
    populateUserSelects();

  } catch(e) {
    console.error("Error loadUsers", e);
    populateUserSelects(); // vaciar selects
  }
}



  function populateUserSelects(){
    [player1Select, player2Select].forEach(sel=>{
      sel.innerHTML = '<option value="">-- elegir --</option>';
      allUsers.forEach(u=>{
        const opt = document.createElement('option');
        opt.value = u.id;
        opt.textContent = u.nombre;
        sel.appendChild(opt);
      });
    });
  }

  // ---------------------- Obtener tarjetas (reusa lógica) ----------------------
  async function obtenerTarjetasConScores() {
    try {
      const tarjetasCol = collection(db, 'tarjetas');
      const q = query(tarjetasCol, where('juegoId','==', juegoId));
      const snap = await getDocs(q);
      const tarjetas = [];
      snap.forEach(d => {
        const data = d.data();
        const scores = Array.isArray(data.scores) ? data.scores : [];
        const hasAny = scores.some(s => {
          const g = s.golpes;
          return (typeof g === 'number' && !isNaN(g)) || (typeof g === 'string' && !isNaN(Number(g)));
        });
        if (hasAny) { tarjetas.push({ id: d.id, ...data }); }
      });
      tarjetasCache = tarjetas;
      return tarjetas;
    } catch (err) {
      console.error('Error obteniendo tarjetas', err);
      tarjetasCache = [];
      return [];
    }
  }

  // ---------------------- Obtener pares por hoyo y ventajas (camposGolf) ----------------------
  async function obtenerParYVentajas(campoId) {
    if (!campoId) return { pares:null, vantM:null, vantF:null };
    if (camposCache[campoId]) return camposCache[campoId];
    try {
      const cref = doc(db, 'camposGolf', campoId);
      const csnap = await getDoc(cref);
      if (!csnap.exists()) { camposCache[campoId] = { pares:null, vantM:null, vantF:null }; return camposCache[campoId]; }
      const cdata = csnap.data();
      const pares = Array.isArray(cdata.paresHoyo) ? cdata.paresHoyo : (Array.isArray(cdata.pares_hoyo)?cdata.pares_hoyo:null);
      // detect possible keys for ventajas por genero (tolerante)
      const vantM = Array.isArray(cdata.ventajasM) ? cdata.ventajasM
                    : Array.isArray(cdata.ventajas_m) ? cdata.ventajas_m
                    : Array.isArray(cdata.ventajasMale) ? cdata.ventajasMale
                    : Array.isArray(cdata.advantagesMale) ? cdata.advantagesMale
                    : Array.isArray(cdata.ventajasHombre) ? cdata.ventajasHombre
                    : null;
      const vantF = Array.isArray(cdata.ventajasF) ? cdata.ventajasF
                    : Array.isArray(cdata.ventajas_f) ? cdata.ventajas_f
                    : Array.isArray(cdata.ventajasFemale) ? cdata.ventajasFemale
                    : Array.isArray(cdata.advantagesFemale) ? cdata.advantagesFemale
                    : Array.isArray(cdata.ventajasMujer) ? cdata.ventajasMujer
                    : null;
      camposCache[campoId] = { pares, vantM, vantF };
      return camposCache[campoId];
    } catch (e) {
      console.error('Error obtenerParYVentajas', e);
      camposCache[campoId] = { pares:null, vantM:null, vantF:null };
      return camposCache[campoId];
    }
  }

  // ---------------------- PARES: manejo UI ----------------------
  function renderPairsList(){
    pairsList.innerHTML = '';
    pairs.forEach((p, idx) => {
      const pill = document.createElement('div');
      pill.className = 'pair-pill';
      pill.style.background = p.color;
      pill.innerHTML = `
        <div style="display:flex;gap:8px;align-items:center;">
          <div style="display:flex;flex-direction:column; margin-right:6px;">
            <div style="font-size:0.75rem; opacity:0.95">Pareja ${idx+1}</div>
            <div style="font-size:0.8rem;opacity:0.9">${getUserName(p.p1Uid)} & ${getUserName(p.p2Uid)}</div>
          </div>
        </div>
        <button data-idx="${idx}" style="margin-left:8px;background:transparent;border:0;color:#fff;cursor:pointer;font-weight:900">X</button>
      `;
      pairsList.appendChild(pill);
      pill.querySelector('button').addEventListener('click', ()=> { pairs.splice(idx,1); renderPairsList(); });
    });
  }

  function getUserName(uid){
   const u = allUsers.find(x=>x.id===uid);
    return u ? u.nombre : uid;
  }

  function getMyPair() {
    if (!currentUser || !pairs || pairs.length === 0) return null;
    return pairs.find(
      p => p.p1Uid === currentUser.uid || p.p2Uid === currentUser.uid
    ) || null;
  }



  addPairBtn.addEventListener('click', ()=>{
    const p1 = player1Select.value;
    const p2 = player2Select.value;
    if(!p1 || !p2){ alert('Selecciona ambos jugadores'); return; }
    if(p1===p2){ if(!confirm('Has escogido el mismo usuario dos veces. Confirmar pareja igual?')) return; }
    const color = randColor();
    pairs.push({
        id: 'pair_'+Date.now()+'_'+Math.floor(Math.random()*9999),
        p1Uid: p1,
        p2Uid: p2,
        color
    });

    renderPairsList();
  });

  refreshBtn.addEventListener('click', async ()=>{ await initAll(); });

startGameBtn.addEventListener("click", async () => {
  try {
    if (!juegoId) { console.error("Faltan datos: juegoId"); return; }
    if (!grupoId) await ensureGrupoId();

    const foursomeRef = doc(db, "juego_foursomes", juegoId);
    const foursomeSnap = await getDoc(foursomeRef);

    if (foursomeSnap.exists()) {
      const jfData = foursomeSnap.data();
      pairs = Array.isArray(jfData?.pairs) ? jfData.pairs : [];
      priceInput.value = jfData?.price || '';
    } else {
      await setDoc(foursomeRef, {
        juegoId,
        grupoId,
        price: priceInput.value || '',
        pairs: pairs || [],
        createdAt: serverTimestamp(),
      });
    }

    // reasignar myPair
    if(currentUser){
      myPair = pairs.find(p => p.p1Uid === currentUser.uid || p.p2Uid === currentUser.uid) || null;
    }

    gameArea.style.display = 'block';
    document.querySelector('.card').style.display = 'none';
    gameMeta.innerText = `Juego ${juegoId} — Precio por pareja ${priceInput.value} — Parejas: ${pairs.length}`;

    await computeAndRenderAllMatchups(Number(priceInput.value), myPair);

  } catch (err) {
    console.error("Error al iniciar juego:", err);
  }
});


  // ---------------------- Lógica de cálculo de matchups ----------------------
  function findTarjetaForUser(uid) {
    // Busca por userUid en tarjetasCache
    return tarjetasCache.find(t => t.userUid === uid) || null;
  }

  function buildGolpesArrFromTarjeta(t) {
    const arr = new Array(18).fill(null);
    const scores = Array.isArray(t.scores) ? t.scores : [];
    scores.forEach(s=>{
      const hoyo = Number(s.hoyo);
      const golpesRaw = s.golpes;
      const golpes = (typeof golpesRaw === 'number') ? golpesRaw : (typeof golpesRaw === 'string' ? (isNaN(Number(golpesRaw))?null:Number(golpesRaw)) : null);
      if(!isNaN(hoyo) && hoyo>=1 && hoyo<=18 && typeof golpes === 'number') arr[hoyo-1] = golpes;
    });
    return arr;
  }

  function genderOfUser(userObj) {
    const g = (userObj?.gender||'M').toString().toLowerCase();
    if(g.startsWith('f')) return 'F';
    return 'M';
  }

  // aplica ventaja: devuelve golpes ajustados (sin alterar tarjeta)
  function applyAdvantageToGolpesArray(golpesArr, userData, fieldVentajas) {
    // fieldVentajas: { vantM, vantF } arrays or null
    const result = new Array(18).fill(null);
    for(let i=0;i<18;i++){
      const raw = golpesArr[i];
      if (typeof raw !== 'number') { result[i] = null; continue; }
      let adj = raw;
      const gender = genderOfUser(userData);
      const handicap = userData.handicap || 0;
      const vantArr = (gender === 'M') ? fieldVentajas.vantM : fieldVentajas.vantF;
      const v = Array.isArray(vantArr) ? (Number(vantArr[i]) || 0) : 0;
      // si handicap >= v entonces se resta 1 punto
      if (v && handicap >= v) adj = adj - 1;
      result[i] = adj;
    }
    return result;
  }
function getUserObj(uid) {
  return allUsers.find(u=>u.id===uid) || { handicap:0, gender:'M' };
}

  // compara 2 parejas: devuelve objeto con tabla por hoyo y suma de puntos por pareja (array [pointsA, pointsB])
  async function computeMatchup(pairA, pairB, price) {
    const pA1 = findTarjetaForUser(pairA.p1Uid);
    const pA2 = findTarjetaForUser(pairA.p2Uid);
    const pB1 = findTarjetaForUser(pairB.p1Uid);
    const pB2 = findTarjetaForUser(pairB.p2Uid);

    const campoId = (pA1?.campoId || pA2?.campoId || pB1?.campoId || pB2?.campoId) || null;
    const fieldInfo = await obtenerParYVentajas(campoId);

    const a1Arr = pA1 ? applyAdvantageToGolpesArray(buildGolpesArrFromTarjeta(pA1), getUserObj(pairA.p1Uid), fieldInfo) : new Array(18).fill(null);
    const a2Arr = pA2 ? applyAdvantageToGolpesArray(buildGolpesArrFromTarjeta(pA2), getUserObj(pairA.p2Uid), fieldInfo) : new Array(18).fill(null);
    const b1Arr = pB1 ? applyAdvantageToGolpesArray(buildGolpesArrFromTarjeta(pB1), getUserObj(pairB.p1Uid), fieldInfo) : new Array(18).fill(null);
    const b2Arr = pB2 ? applyAdvantageToGolpesArray(buildGolpesArrFromTarjeta(pB2), getUserObj(pairB.p2Uid), fieldInfo) : new Array(18).fill(null);

    const holes = [];
    let totalA = 0, totalB = 0;

    for (let h = 0; h < 18; h++) {
      const scoresA = [a1Arr[h], a2Arr[h]].filter(x=>typeof x==='number');
      const scoresB = [b1Arr[h], b2Arr[h]].filter(x=>typeof x==='number');

      let ptsA=0, ptsB=0;

      if (scoresA.length && scoresB.length) {
        const lowA = Math.min(...scoresA);
        const highA = Math.max(...scoresA);
        const lowB = Math.min(...scoresB);
        const highB = Math.max(...scoresB);

        if(lowA < lowB) ptsA++; else if(lowB < lowA) ptsB++;
        if(highA < highB) ptsA++; else if(highB < highA) ptsB++;
      }

      totalA += ptsA;
      totalB += ptsB;

      holes.push({
        players:[
          { uid: pairA.p1Uid, name:getUserName(pairA.p1Uid), initials:getUserObj(pairA.p1Uid).initials, adj: a1Arr[h], teamColor: pairA.color },
          { uid: pairA.p2Uid, name:getUserName(pairA.p2Uid), initials:getUserObj(pairA.p2Uid).initials, adj: a2Arr[h], teamColor: pairA.color },
          { uid: pairB.p1Uid, name:getUserName(pairB.p1Uid), initials:getUserObj(pairB.p1Uid).initials, adj: b1Arr[h], teamColor: pairB.color },
          { uid: pairB.p2Uid, name:getUserName(pairB.p2Uid), initials:getUserObj(pairB.p2Uid).initials, adj: b2Arr[h], teamColor: pairB.color },
        ],
        pointsA: ptsA,
        pointsB: ptsB
      });
    }

    return {
      pairA, pairB, holes,
      totalPointsA: totalA,
      totalPointsB: totalB,
      saldo: totalA-totalB,
      price
    };
  }

  async function computeAndRenderAllMatchups(pricePerPair, myPair) {
  matchupsContainer.innerHTML = "";

  await obtenerTarjetasConScores();

  // asumimos pares de 2 en 2
  for (let i = 0; i < pairs.length; i += 2) {
    const pairA = pairs[i];
    const pairB = pairs[i + 1];
    if (!pairA || !pairB) continue;

    const colorA = pairA.color;
    const colorB = pairB.color;

    // construir jugadores
    const playersA = [pairA.p1Uid, pairA.p2Uid].map(uid => {
      const u = allUsers.find(x => x.id === uid);
      const tarjeta = findTarjetaForUser(uid);
      const golpes = tarjeta ? buildGolpesArrFromTarjeta(tarjeta) : new Array(18).fill(null);
      return { uid, user: u, golpes };
    });

    const playersB = [pairB.p1Uid, pairB.p2Uid].map(uid => {
      const u = allUsers.find(x => x.id === uid);
      const tarjeta = findTarjetaForUser(uid);
      const golpes = tarjeta ? buildGolpesArrFromTarjeta(tarjeta) : new Array(18).fill(null);
      return { uid, user: u, golpes };
    });

    // tabla
    const table = document.createElement("table");
    let thead = `<thead><tr><th class="nameCol">Jugador</th>`;
    for (let h = 1; h <= 18; h++) thead += `<th>${h}</th>`;
    thead += "</tr></thead>";
    table.innerHTML = thead;

    const tbody = document.createElement("tbody");

    // render jugadores
    function renderPlayerRow(player, pairColor) {
      const tr = document.createElement("tr");
      tr.innerHTML = `<td class="nameCol" style="background:${pairColor};color:#fff;">${player.user?.nombre || player.uid}</td>`;
      for (let h = 0; h < 18; h++) {
        const golpes = player.golpes[h];
        const td = document.createElement("td");
        td.textContent = golpes ?? "-";
        tr.appendChild(td);
      }
      tbody.appendChild(tr);
    }
    playersA.forEach(p => renderPlayerRow(p, colorA));
    playersB.forEach(p => renderPlayerRow(p, colorB));

    // marcador por hoyo
    const scoreRow = document.createElement("tr");
    scoreRow.innerHTML = `<td class="nameCol">Marcador</td>`;
    for (let h = 0; h < 18; h++) {
      // obtener scores de cada jugador en este hoyo
      const scores = [...playersA, ...playersB].map(p => ({
        player: p,
        golpes: typeof p.golpes[h] === "number" ? p.golpes[h] : null
      }));

      // descartar nulls
      const validScores = scores.filter(s => s.golpes !== null);
      if (validScores.length < 4) {
        scoreRow.innerHTML += `<td class="hole-empty">-</td>`;
        continue;
      }

      // ordenar por golpes
      validScores.sort((a, b) => a.golpes - b.golpes);

      // si hay empate múltiple
      let matchPairs;
      if (new Set(validScores.map(s => s.golpes)).size <= 2) {
        // todos iguales o 3 iguales: asignación random
        matchPairs = [
          [validScores[0], validScores[2]],
          [validScores[1], validScores[3]]
        ];
      } else {
        // normal: bajo vs bajo, alto vs alto
        const lowA = playersA.reduce((min, p) => (p.golpes[h] < min.golpes[h] ? p : min), playersA[0]);
        const highA = playersA.reduce((max, p) => (p.golpes[h] > max.golpes[h] ? p : max), playersA[0]);
        const lowB = playersB.reduce((min, p) => (p.golpes[h] < min.golpes[h] ? p : min), playersB[0]);
        const highB = playersB.reduce((max, p) => (p.golpes[h] > max.golpes[h] ? p : max), playersB[0]);
        matchPairs = [
          [ {player: lowA, golpes: lowA.golpes[h]}, {player: lowB, golpes: lowB.golpes[h]} ],
          [ {player: highA, golpes: highA.golpes[h]}, {player: highB, golpes: highB.golpes[h]} ]
        ];
      }

      // aplicar colores en celdas
      matchPairs.forEach(([a, b]) => {
        const winner = a.golpes < b.golpes ? a : (b.golpes < a.golpes ? b : null);
        const loser = winner ? (winner === a ? b : a) : null;

        [a, b].forEach(p => {
          const row = [...tbody.rows].find(r => r.cells[0].textContent === (p.player.user?.nombre || p.player.uid));
          if (row) {
            const td = row.cells[h + 1];
            td.style.background = (p.player === playersA[0] || p.player === playersA[1]) ? colorA : colorB;
            td.style.color = winner === p ? "green" : loser === p ? "red" : "black";
          }
        });
      });

      // marcador de parejas
      let sumA = playersA.reduce((acc, p) => acc + (p.golpes[h] ?? 0), 0);
      let sumB = playersB.reduce((acc, p) => acc + (p.golpes[h] ?? 0), 0);
      let cell = "";
      if (sumA < sumB) {
        cell = `<td style="background:${colorA};color:green;">+1</td>`;
      } else if (sumB < sumA) {
        cell = `<td style="background:${colorB};color:green;">+1</td>`;
      } else {
        cell = `<td style="background:#eee;color:black;">0</td>`;
      }
      scoreRow.innerHTML += cell;
    }

    tbody.appendChild(scoreRow);
    table.appendChild(tbody);
    matchupsContainer.appendChild(table);
  }
}



  // ---------------------- INIT ----------------------
  async function initAll() {
    try {
      await ensureGrupoId();
      await loadUsers();
      await obtenerTarjetasConScores();

      const jfRef = doc(db, 'juego_foursomes', juegoId);
      const jfSnap = await getDoc(jfRef);
      if (jfSnap.exists()) {
        const jfData = jfSnap.data();
        grupoId = jfData?.grupoId || grupoId;
        pairs = Array.isArray(jfData?.pairs) ? jfData.pairs : [];
        priceInput.value = jfData?.price || '';
        renderPairsList();

        // asignar myPair solo si currentUser existe
        if(currentUser){
          myPair = pairs.find(p => p.p1Uid === currentUser.uid || p.p2Uid === currentUser.uid) || null;
        }

        if(pairs.length>0 && priceInput.value && myPair){
          gameArea.style.display = 'block';
          document.querySelector('.card').style.display = 'none'; // ocultar form
          gameMeta.innerText = `Juego ${juegoId} — Precio por pareja ${priceInput.value} — Parejas: ${pairs.length}`;
          await computeAndRenderAllMatchups(Number(priceInput.value), myPair);
        }

      } else {
        console.warn("No existe el documento en juego_foursomes todavía");
        renderPairsList();
      }

    } catch(e){
      console.error('initAll: error al inicializar', e);
    }
  }


  onAuthStateChanged(authInst, async (user)=>{
    currentUser = user;
    if(!user){
      // still load users but show limited
      await initAll();
      return;
    }
    await initAll();
  });

</script>
</body>
</html>
