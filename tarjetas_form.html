<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Completar Tarjetas - Golftrix</title>
<link rel="icon" href="logo_golftrix.png" type="image/png" />
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700&display=swap" rel="stylesheet" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<link rel="stylesheet" href="menu.css" />
<style>
/* Reutiliza estilos similares a tarjeta.html */
body { 
  font-family:'Orbitron',sans-serif; 
  margin:0; 
  padding:0;  /* CAMBIADO: quitar padding general */
  background: #f6f6f6; 
  color:#111;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
}

/* NUEVO: HEADER ESTILO GOLFTRIX */
  header {
      background: linear-gradient(90deg, #007f00, #00cc44);
      display: flex;
      align-items: center;
      justify-content: center; /* Para centrar el título horizontalmente */
      position: relative;
      padding: 20px 40px;
      color: white;
      height: 80px; /* para dar altura fija */
    }

    /* Título centrado absoluto */
    header h1 {
      font-size: 2rem;
      margin: 0;
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
    }

    /* Logo a la derecha, grande */
    header img {
      height: 100px;
      position: absolute;
      right: 20px;
      cursor: pointer;
    }

/* Ajustes para móvil */
@media (max-width: 768px) {
  header {
    flex-direction: column;
    height: auto;
    padding: 20px;
    position: static;
  }

  header img {
    position: static;
    height: 60px;
    order: 1;
    margin-bottom: 10px;
  }

  header h1 {
    position: static;
    order: 2;
    transform: none;
    font-size: 1.8rem;
  }
}

.container { 
  max-width:1000px; 
  margin:0 auto; 
  padding: 20px 12px; /* AGREGAR padding aquí en vez de en body */
  flex: 1;
}

/* Estado y badges */
.badge { background:#eaf9ea; color:#006400; padding:6px 10px; border-radius:10px; font-weight:800; }

/* Campo select */
.field { margin-bottom:10px; }
.select { width:100%; padding:8px; border-radius:8px; height:40px; }

/* Tarjeta */
.card { background:#fafafa; padding:20px; border-radius:12px; box-shadow:0 4px 12px rgba(0,0,0,0.08); }

/* Hoyos grid: 2 columnas desktop, 1 en móvil */
.hoyos-grid { display:grid; grid-template-columns: repeat(2, 1fr); gap:10px; margin-top:15px; }
@media (max-width:700px) {
  .hoyos-grid { grid-template-columns: 1fr; }
}
.hoyo-card { background:#fff; padding:10px; border-radius:8px; box-shadow:0 2px 6px rgba(0,0,0,0.04); text-align:center; border:1px solid #e0e0e0; }
.hoyo-card label { display:block; font-weight:700; margin-bottom:6px; font-size:0.85rem; color:#333; }
.hoyo-card input { width:100%; padding:8px; height:40px; border-radius:6px; text-align:center; border:1px solid #ccc; font-size:1rem; }
.hoyo-card input:focus { border-color:#007f00; outline:none; box-shadow:0 0 0 2px rgba(0,127,0,0.2); }

/* botones */
.btn { padding:12px 20px; border-radius:10px; cursor:pointer; font-weight:800; border:none; font-size:1rem; transition:all 0.3s; }
.save { background: linear-gradient(90deg,#007f00,#00cc44); color:#fff; }
.save:hover { background: linear-gradient(90deg,#006600,#00aa33); transform:translateY(-2px); box-shadow:0 4px 12px rgba(0,127,0,0.3); }
.cancel { background:#eee; color:#222; }
.cancel:hover { background:#ddd; transform:translateY(-2px); box-shadow:0 4px 12px rgba(0,0,0,0.1); }
.btn:disabled { opacity:0.5; cursor:not-allowed; transform:none !important; box-shadow:none !important; }

/* small note */
.small { font-size:0.88rem; color:#666; }

/* Estilos para el flujo paso a paso */
#currentCardTitle {
  color: #005600;
  margin-bottom: 5px;
  font-size: 1.5rem;
}

#progressText {
  color: #666;
  font-style: italic;
  margin-bottom: 20px;
}

/* Mejorar visualización de inputs */
input[type="date"], select {
  font-family: 'Orbitron', sans-serif;
  border: 1px solid #ccc;
  transition: border-color 0.3s;
  font-size: 0.95rem;
}

input[type="date"]:focus, select:focus {
  border-color: #007f00;
  outline: none;
  box-shadow: 0 0 0 2px rgba(0, 127, 0, 0.2);
}

/* Estilo para mensajes */
#resultMsg {
  padding: 12px;
  border-radius: 8px;
  background-color: #f8f9fa;
  min-height: 50px;
  margin-top: 20px;
  border-left: 4px solid #007f00;
}

/* Animación suave entre tarjetas */
.card {
  animation: fadeIn 0.5s ease-out;
}

@keyframes fadeIn {
  from { opacity: 0; transform: translateY(10px); }
  to { opacity: 1; transform: translateY(0); }
}

/* Navegación */
.navigation-buttons {
  display: flex;
  gap: 15px;
  justify-content: center;
  margin-top: 30px;
  flex-wrap: wrap;
}

.navigation-buttons .btn i {
  margin: 0 5px;
}

/* Grid para fecha y selects */
.form-row {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  gap: 15px;
  margin-bottom: 20px;
}

.form-group {
  display: flex;
  flex-direction: column;
}

.form-group label {
  margin-bottom: 5px;
  font-weight: 600;
  color: #333;
}
</style>
</head>
<body>
  <header>
    <div id="menuContainer"></div>
    <h1>Completar Tarjetas - Golftrix</h1>
    <img src="logo_golftrix.png" alt="Logo" id="logo" />
</header>
<div class="container">
  <!-- Estado y progreso -->
  <div id="statusLine" class="small" style="text-align: center; margin-bottom: 15px;"></div>
  
  <div style="text-align: center; margin-bottom: 15px;">
    <div id="missingBadge" class="badge" style="display: none; margin: 0 auto;"></div>
  </div>

  <!-- Indicador de tarjeta actual -->
  <div style="text-align: center; margin-bottom: 20px;">
    <h3 id="currentCardTitle">Tarjeta 1 de <span id="totalCards">0</span></h3>
    <div class="small" id="progressText">Completa los datos de la tarjeta</div>
  </div>

  <!-- Formulario de tarjeta actual (solo una visible) -->
  <div id="currentCardContainer">
    <!-- Los inputs se generarán aquí dinámicamente -->
  </div>

  <!-- Navegación -->
  <div class="navigation-buttons">
    <button id="prevBtn" class="btn cancel" style="display: none;">
      <i class="fas fa-arrow-left"></i> Atrás
    </button>
    
    <button id="nextBtn" class="btn save">
      Siguiente <i class="fas fa-arrow-right"></i>
    </button>
    
    <button id="saveFinalBtn" class="btn save" style="display: none;">
      <i class="fas fa-save"></i> Guardar y Calcular Handicap
    </button>
  </div>

  <!-- Mensajes de resultado -->
  <div id="resultMsg" style="margin-top: 20px; text-align: center;" class="small"></div>
</div>

<footer style="background: #000; color: white; text-align: center; padding: 15px;">
  &copy; 2025 Golftrix. Todos los derechos reservados.
</footer>

<script>
function getQueryParam(n){ const u=new URL(location.href); return u.searchParams.get(n); }
</script>

<script type="module">
import { app, db } from './firebase-config.js';
import { calculateAndSaveHandicap } from './handicap.js'; // importa el módulo anterior
import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";
import {
  collection,
  query,
  where,
  orderBy,
  getDocs,
  addDoc,
  serverTimestamp,
  doc,
  setDoc,
  getDoc,
  limit
} from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

const auth = getAuth(app);

// Agregar evento click al logo para ir al dashboard
const logo = document.getElementById('logo');
if (logo) {
  logo.addEventListener('click', () => window.location.href = 'dashboard.html');
}

// DOM
let currentUserUid = null;
let availableCardsCount = 0;
let missingCount = 0;
let campos = []; // lista de camposGolf

// VARIABLES NUEVAS PARA EL FLUJO POR PASOS
let currentCardIndex = 0; // Índice de tarjeta actual (0-based)
let maxCardsToFill = 0;   // Número de tarjetas a llenar
let tempEntries = [];     // Datos de todas las tarjetas
let salidaOptions = ['Blancas', 'Azules', 'Rojas']; // Opciones de salida

// Referencias DOM NUEVAS
const currentCardContainer = document.getElementById('currentCardContainer');
const currentCardTitle = document.getElementById('currentCardTitle');
const totalCardsSpan = document.getElementById('totalCards');
const progressText = document.getElementById('progressText');
const prevBtn = document.getElementById('prevBtn');
const nextBtn = document.getElementById('nextBtn');
const saveFinalBtn = document.getElementById('saveFinalBtn');
const missingBadge = document.getElementById('missingBadge');
const statusLine = document.getElementById('statusLine');
const resultMsg = document.getElementById('resultMsg');

// cargar campos de golf
async function loadCampos() {
  // Limpiar el array de campos primero
  campos = [];
  
  try {
    const q = query(collection(db, 'camposGolf'), orderBy('nombre'));
    const snap = await getDocs(q);
    
    snap.forEach(s => {
      const d = s.data();
      campos.push({ id: s.id, nombre: d.nombre || 'Sin nombre' });
    });
    
    console.log(`Campos cargados: ${campos.length}`);
  } catch (error) {
    console.error('Error cargando campos:', error);
    campos = []; // Asegurar que está vacío si hay error
  }
}

// calcula cuántas tarjetas completas tiene el usuario
async function countUserCompleteCards(uid) {
  // traemos tarjetas ownerUid==uid y filtramos por 18 hoyos completos
  // para eficiencia limitamos a 50
  const q = query(collection(db, 'tarjetas'), where('ownerUid', '==', uid), orderBy('createdAtMillis', 'desc'), limit(50));
  const snap = await getDocs(q);
  let count = 0;
  snap.forEach(snapDoc => {
    const d = snapDoc.data();
    if (d?.scores && Array.isArray(d.scores) && d.scores.length >= 18) {
      // chequeo simple: que existan hoyos 1..18
      const set = new Set(d.scores.map(x => x.hoyo));
      let ok = true;
      for (let i = 1; i <= 18; i++) { if (!set.has(i)) { ok = false; break; } }
      if (ok) count++;
    }
  });
  return count;
}

// flujo inicial: contar tarjetas y preparar vista
async function prepareFormForUser(uid) {
  try {
    statusLine.textContent = 'Consultando tarjetas y campos...';
    resultMsg.textContent = '';
    
    // Cargar campos primero
    await loadCampos();
    
    // Contar tarjetas existentes
    const count = await countUserCompleteCards(uid);
    availableCardsCount = count;
    missingCount = Math.max(0, 10 - availableCardsCount);
    
    // Mostrar estado
    missingBadge.style.display = missingCount > 0 ? 'inline-block' : 'none';
    missingBadge.textContent = missingCount > 0 ? 
      `Te hacen falta ${missingCount} tarjetas para calcular handicap` : 
      'Tienes 10 o más tarjetas';
    
    statusLine.textContent = `Tarjetas completas encontradas: ${availableCardsCount}`;
    
    // Determinar cuántas tarjetas mostrar
    maxCardsToFill = missingCount > 0 ? missingCount : 1;
    if (maxCardsToFill === 0) maxCardsToFill = 1; // Siempre mostrar al menos 1
    
    totalCardsSpan.textContent = maxCardsToFill;
    
    // Inicializar estructura de datos
    tempEntries = [];
    for (let i = 0; i < maxCardsToFill; i++) {
      tempEntries[i] = { 
        fecha: '', 
        campoId: '', 
        salida: '',  // NUEVO: campo de salida
        scores: {} 
      };
    }
    
    // Mostrar primera tarjeta
    currentCardIndex = 0;
    renderCurrentCard();
    updateNavigationButtons();
    
    // Verificar si hay campos disponibles
    if (campos.length === 0) {
      resultMsg.textContent = '⚠️ No hay campos de golf registrados. Contacta al administrador.';
      resultMsg.style.color = '#ff9800';
    }
    
  } catch (error) {
    console.error('Error en prepareFormForUser:', error);
    statusLine.textContent = 'Error cargando datos';
    resultMsg.textContent = '❌ Error al cargar los datos. Intenta recargar la página.';
    resultMsg.style.color = '#d32f2f';
  }
}



// Renderiza solo la tarjeta actual
function renderCurrentCard() {
  const entry = tempEntries[currentCardIndex] || { fecha: '', campoId: '', salida: '', scores: {} };
  
  // Si es tarjeta 2 o superior, propagar valores de la anterior si están vacíos
  if (currentCardIndex > 0) {
    const prevEntry = tempEntries[currentCardIndex - 1];
    if (!entry.fecha && prevEntry.fecha) entry.fecha = prevEntry.fecha;
    if (!entry.campoId && prevEntry.campoId) entry.campoId = prevEntry.campoId;
    if (!entry.salida && prevEntry.salida) entry.salida = prevEntry.salida;
  }
  
  currentCardContainer.innerHTML = `
    <div class="card">
      <div class="form-row">
        <div class="form-group">
          <label class="small">Fecha</label>
          <input type="date" id="fechaInput" value="${entry.fecha || ''}" class="select" />
        </div>
        
        <div class="form-group">
          <label class="small">Campo de golf</label>
          <select id="campoSelectInput" class="select">
            <option value="">-- Selecciona campo --</option>
            ${campos.map(c => `<option value="${c.id}" ${entry.campoId === c.id ? 'selected' : ''}>${c.nombre}</option>`).join('')}
          </select>
        </div>
        
        <div class="form-group">
          <label class="small">Salida</label>
          <select id="salidaSelectInput" class="select">
            <option value="">-- Selecciona salida --</option>
            ${salidaOptions.map(s => `<option value="${s}" ${entry.salida === s ? 'selected' : ''}>${s}</option>`).join('')}
          </select>
        </div>
      </div>
      
      <div style="margin-top:20px;">
        <div class="small" style="margin-bottom:10px; font-weight:bold; text-align:center;">
          Ingresa los scores para los 18 hoyos:
        </div>
        <div class="hoyos-grid" id="hoyosGrid"></div>
      </div>
    </div>
  `;
  
    // Hoyos grid
  const grid = document.getElementById('hoyosGrid');
  grid.innerHTML = '';
  
  // Usar event delegation para evitar múltiples event listeners
  // Limpiar eventos previos primero
  currentCardContainer.replaceWith(currentCardContainer.cloneNode(true));
  
  for (let i = 1; i <= 18; i++) {
    const val = entry.scores && typeof entry.scores[i] !== 'undefined' ? entry.scores[i] : '';
    const div = document.createElement('div');
    div.className = 'hoyo-card';
    div.innerHTML = `
      <label>Hoyo ${i}</label>
      <input type="number" min="0" max="20" id="hoyo-${i}" value="${val}" />
    `;
    grid.appendChild(div);
  }
  
  // Adjuntar eventos usando event delegation (UNA SOLA VEZ)
  attachInputEvents();
  
  // Actualizar título
  currentCardTitle.textContent = `Tarjeta ${currentCardIndex + 1} de ${maxCardsToFill}`;

}

// Función para adjuntar eventos a los inputs después de renderizar
function attachInputEvents() {
  // Remover event listeners previos para evitar duplicados
  const newContainer = currentCardContainer.cloneNode(true);
  currentCardContainer.parentNode.replaceChild(newContainer, currentCardContainer);
  
  // Ahora usar el nuevo container
  const container = document.getElementById('currentCardContainer');
  
  // Eventos para fecha y selects
  const fechaInput = container.querySelector('#fechaInput');
  const campoSelect = container.querySelector('#campoSelectInput');
  const salidaSelect = container.querySelector('#salidaSelectInput');
  
  if (fechaInput) {
    fechaInput.addEventListener('change', (e) => {
      tempEntries[currentCardIndex].fecha = e.target.value;
      validateCurrentCard();
    });
  }
  
  if (campoSelect) {
    campoSelect.addEventListener('change', (e) => {
      tempEntries[currentCardIndex].campoId = e.target.value;
      validateCurrentCard();
    });
  }
  
  if (salidaSelect) {
    salidaSelect.addEventListener('change', (e) => {
      tempEntries[currentCardIndex].salida = e.target.value;
      validateCurrentCard();
    });
  }
  
  // Eventos para inputs de hoyos usando event delegation en el container
  container.addEventListener('input', (e) => {
    if (e.target.id && e.target.id.startsWith('hoyo-')) {
      const hoyoNum = parseInt(e.target.id.replace('hoyo-', ''));
      const v = e.target.value;
      tempEntries[currentCardIndex].scores[hoyoNum] = v === '' ? undefined : Number(v);
      validateCurrentCard();
    }
  });
}

// Actualiza visibilidad y estado de botones de navegación
function updateNavigationButtons() {
  // Botón Atrás
  prevBtn.style.display = currentCardIndex > 0 ? 'inline-block' : 'none';
  
  // Botón Siguiente vs Guardar Final
  if (currentCardIndex === maxCardsToFill - 1) {
    // Última tarjeta
    nextBtn.style.display = 'none';
    saveFinalBtn.style.display = 'inline-block';
    progressText.textContent = 'Última tarjeta. Verifica los datos y guarda.';
  } else {
    // No es la última
    nextBtn.style.display = 'inline-block';
    saveFinalBtn.style.display = 'none';
    progressText.textContent = `Completa los datos de la tarjeta ${currentCardIndex + 1}`;
  }
  
  // Validar si la tarjeta actual está completa
  validateCurrentCard();
}

// Valida si la tarjeta actual tiene todos los datos necesarios
function validateCurrentCard() {
  const entry = tempEntries[currentCardIndex];
  let isValid = true;
  let message = '';
  
  // Validar fecha
  if (!entry.fecha) {
    isValid = false;
    message = 'La fecha es requerida';
  }
  
  // Validar 18 hoyos
  if (isValid) {
    for (let i = 1; i <= 18; i++) {
      if (typeof entry.scores[i] !== 'number' || Number.isNaN(entry.scores[i])) {
        isValid = false;
        message = `Falta el hoyo ${i}`;
        break;
      }
    }
  }
  
  // Actualizar estado del botón siguiente
  nextBtn.disabled = !isValid;
  saveFinalBtn.disabled = !isValid;
  
  // Mostrar mensaje de validación
  if (!isValid && message) {
    resultMsg.textContent = `⚠️ ${message}`;
    resultMsg.style.color = '#d32f2f';
  } else {
    resultMsg.textContent = '';
  }
  
  return isValid;
}

// guardar todas las tarjetas creadas por el usuario en firestore
async function saveAllCardsAndRecalc(uid) {
  // Deshabilitar botón para evitar doble clic
  saveFinalBtn.disabled = true;
  saveFinalBtn.textContent = 'Guardando...';
  
  resultMsg.textContent = 'Validando tarjetas...';
  resultMsg.style.color = '#006400';
  
  // Validar todas las tarjetas
  for (let t = 0; t < maxCardsToFill; t++) {
    const e = tempEntries[t];
    
    // Validar fecha
    if (!e.fecha) {
      resultMsg.textContent = `La tarjeta ${t+1} no tiene fecha.`;
      resultMsg.style.color = '#d32f2f';
      saveFinalBtn.disabled = false;
      saveFinalBtn.textContent = '<i class="fas fa-save"></i> Guardar y Calcular Handicap';
      return;
    }
    
    // Validar 18 hoyos
    for (let i = 1; i <= 18; i++) {
      if (typeof e.scores[i] !== 'number' || Number.isNaN(e.scores[i])) {
        resultMsg.textContent = `La tarjeta ${t+1} no tiene el hoyo ${i} completo.`;
        resultMsg.style.color = '#d32f2f';
        saveFinalBtn.disabled = false;
        saveFinalBtn.textContent = '<i class="fas fa-save"></i> Guardar y Calcular Handicap';
        return;
      }
    }
  }

  resultMsg.textContent = 'Guardando tarjetas...';
  
  // crear cada documento en collection 'tarjetas'
  const col = collection(db, 'tarjetas');
  try {
    // Contador para verificar cuántas se guardaron
    let savedCount = 0;
    
    for (let t = 0; t < maxCardsToFill; t++) {
      const e = tempEntries[t];
      
      // construir array scores con la estructura EXACTA que necesita handicap.js
      const scoresArray = [];
      const nowMillis = Date.now();
      const updatedMillis = Date.now();
      
      for (let i = 1; i <= 18; i++) {
        scoresArray.push({
          hoyo: i,
          golpes: Number(e.scores[i]),
          createdAtMillis: nowMillis,
          updatedAtMillis: updatedMillis  // IMPORTANTE: agregar este campo
        });
      }

      // Obtener nombre del campo
      const campoNombre = campos.find(c => c.id === e.campoId)?.nombre || '';

      

      const fechaTimestamp = e.fecha ? new Date(e.fecha) : new Date();
      
      // Crear ID único para juego (puede ser 0 o un timestamp)
      const juegoId = `juego_${Date.now()}_${t}`;
      
      // Estructura EXACTA según el ejemplo que proporcionaste
      const docPayload = {
        campoId: e.campoId || '',
        campoNombre: campoNombre,
        createdAt: serverTimestamp(),  // Usar serverTimestamp en lugar de Date
        estado: 'activa',
        juegoId: juegoId,  // REQUERIDO por handicap.js
        lastUpdated: serverTimestamp(),
        ownerUid: uid,
        salida: e.salida || 'Blancas',  // Valor por defecto si está vacío
        scores: scoresArray,  // Array con la estructura correcta
        userUid: uid
      };

      console.log(`Guardando tarjeta ${t+1}:`, docPayload);
      await addDoc(col, docPayload);
      savedCount++;
    }

    resultMsg.textContent = `${savedCount} tarjetas guardadas correctamente. Calculando handicap...`;

    // recalcular y guardar handicap
    const res = await calculateAndSaveHandicap(uid);
    
    if (res.ok && res.saved) {
      resultMsg.textContent = `✅ Handicap calculado y guardado: ${res.handicap}`;
      resultMsg.style.color = '#006400';
      
      // Redirigir después de 3 segundos
      setTimeout(() => {
        window.location.href = 'dashboard.html';
      }, 3000);
      
    } else if (res.ok && !res.saved) {
      resultMsg.textContent = `ℹ️ Handicap calculado: ${res.handicap} (no se pudo guardar automáticamente).`;
      resultMsg.style.color = '#ff9800';
      // Rehabilitar botón
      saveFinalBtn.disabled = false;
      saveFinalBtn.innerHTML = '<i class="fas fa-save"></i> Guardar y Calcular Handicap';
    } else {
      if (res.missing) {
        resultMsg.textContent = `⚠️ Aún faltan ${res.missing} tarjetas para calcular handicap.`;
        resultMsg.style.color = '#ff9800';
      } else {
        resultMsg.textContent = `❌ Error: ${res.message || 'No se pudo calcular el handicap.'}`;
        resultMsg.style.color = '#d32f2f';
      }
      // Rehabilitar botón
      saveFinalBtn.disabled = false;
      saveFinalBtn.innerHTML = '<i class="fas fa-save"></i> Guardar y Calcular Handicap';
    }
    
  } catch (err) {
    console.error('Error guardando tarjetas:', err);
    resultMsg.textContent = '❌ Error guardando tarjetas. Revisa la consola.';
    resultMsg.style.color = '#d32f2f';
    // Rehabilitar botón
    saveFinalBtn.disabled = false;
    saveFinalBtn.innerHTML = '<i class="fas fa-save"></i> Guardar y Calcular Handicap';
  }
}

// Eventos de navegación
// Generar ID único para juego
function generateJuegoId() {
  return `juego_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
}
prevBtn.addEventListener('click', () => {
  if (currentCardIndex > 0) {
    currentCardIndex--;
    renderCurrentCard();
    updateNavigationButtons();
  }
});

nextBtn.addEventListener('click', () => {
  if (validateCurrentCard()) {
    if (currentCardIndex < maxCardsToFill - 1) {
      currentCardIndex++;
      renderCurrentCard();
      updateNavigationButtons();
    }
  }
});

saveFinalBtn.addEventListener('click', async () => {
  if (!currentUserUid) {
    resultMsg.textContent = 'No hay usuario autenticado.';
    return;
  }
  
  if (validateCurrentCard()) {
    await saveAllCardsAndRecalc(currentUserUid);
  }
});



// Función para iniciar la aplicación después de autenticación
async function initApp() {
  const user = auth.currentUser;
  
  if (!user) {
    // No hay usuario, redirigir después de breve espera
    setTimeout(() => {
      window.location.href = 'index.html';
    }, 1500);
    return;
  }
  
  currentUserUid = user.uid;
  console.log('Usuario autenticado:', currentUserUid);
  
  // Iniciar el formulario
  await prepareFormForUser(currentUserUid);
}

// Iniciar cuando el DOM esté listo
document.addEventListener('DOMContentLoaded', () => {
  console.log('DOM cargado, verificando autenticación...');
  
  // Usar onAuthStateChanged para manejar correctamente la autenticación persistente
  onAuthStateChanged(auth, (user) => {
    if (user) {
      // Usuario autenticado
      currentUserUid = user.uid;
      
      // Solo iniciar si no lo hemos hecho antes
      if (!window.appInitialized) {
        window.appInitialized = true;
        initApp();
      }
    } else {
      // No hay usuario, redirigir
      console.log('No hay usuario autenticado, redirigiendo...');
      setTimeout(() => {
        window.location.href = 'index.html';
      }, 1000);
    }
  });
  
  // Timeout de seguridad por si onAuthStateChanged no se dispara
  setTimeout(() => {
    if (!window.appInitialized && !currentUserUid) {
      console.log('Timeout de autenticación, redirigiendo...');
      window.location.href = 'index.html';
    }
  }, 3000);
});
</script>

<script>
  // Carga menu.html, extrae botón hamburguesa y sidebar, los inserta y luego carga la lógica (menu.js)
  fetch('menu.html')
    .then(res => res.text())
    .then(html => {
      const temp = document.createElement('div');
      temp.innerHTML = html;

      // buscar botón hamburguesa (por id o por clase)
      const hamburgerBtn = temp.querySelector('#hamburger') || temp.querySelector('.hamburger');
      // buscar sidebar (por id o clase)
      const sidebarMenu = temp.querySelector('#sidebarMenu') || temp.querySelector('.sidebar-mobile') || temp.querySelector('.sidebar');

      // coloca el botón hamburger dentro del header (en #menuContainer)
      const container = document.getElementById('menuContainer');
      if (hamburgerBtn && container) {
        container.appendChild(hamburgerBtn);
      }

      // coloca el sidebar al final del body (fuera del header) para que su posicionamiento fijo funcione
      if (sidebarMenu) {
        document.body.appendChild(sidebarMenu);
      }

      // ahora que los nodos están en el DOM, carga la lógica del menú
      import('./menu.js').catch(err => console.error('Error importando menu.js', err));
    })
    .catch(err => {
      console.error('Error cargando menu.html', err);
    });
</script>

</body>
</html>