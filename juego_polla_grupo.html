<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Polla - Grupo — Golftrix</title>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700&display=swap" rel="stylesheet" />
  <style>
    :root{
      --green-start:#007f00;
      --green-end:#00cc44;
    }
    body{ font-family:'Orbitron',sans-serif; margin:0; padding:18px; background:#f6f7f8; color:#111; }
    .card{ background:white; border-radius:12px; padding:12px; box-shadow:0 6px 20px rgba(0,0,0,0.08); margin-bottom:14px; }
    header{ display:flex; align-items:center; justify-content:space-between; gap:12px; }
    header h1{ margin:0; color:var(--green-start); font-size:1.2rem; }
    .top-actions{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }

    .input-inline{ display:flex; gap:8px; align-items:center; }
    input[type="number"]{ padding:8px 10px; border-radius:8px; border:2px solid transparent; background-image: linear-gradient(white, white), linear-gradient(90deg,var(--green-start),var(--green-end)); background-origin: padding-box, border-box; background-clip: padding-box, border-box; width:120px; text-align:center; font-weight:700; }
    button.primary{ background: linear-gradient(90deg,var(--green-start),var(--green-end)); color:#fff; border:0; padding:8px 12px; border-radius:10px; cursor:pointer; font-weight:800; }
    .small { font-size:0.9rem; color:#666; }

    .saldo { font-weight:800; font-size:1.05rem; }

    /* tabla */
    table{ width:100%; border-collapse:collapse; font-size:0.92rem; }
    th, td{ padding:6px 8px; border-bottom:1px solid rgba(0,0,0,0.06); text-align:center; vertical-align:middle; }
    th.sticky{ position:sticky; top:0; background:white; z-index:2; }

    /* avatar circular */
    .avatar {
      width:36px; height:36px; border-radius:50%; display:inline-flex; align-items:center; justify-content:center;
      background:#000; color:#fff; font-weight:800; border:3px solid;
      border-image: linear-gradient(90deg,var(--green-start),var(--green-end)) 1;
      box-shadow: 0 2px 8px rgba(0,0,0,0.12);
    }
    .user-cell { display:flex; gap:8px; align-items:center; justify-content:flex-start; }

    /* colores por hoyo: amarillo = bajo par (mejor), verde = par, rojo = sobre par (peor) */
    .hole-below { background: #fff7c2; } /* amarillo suave */
    .hole-par { background: #e5f8e8; } /* verde suave */
    .hole-above { background: #ffe6e6; } /* rojo suave */

    .totals { font-weight:800; }

    /* responsive: colapsa tabla horizontalmente con scroll */
    .table-wrap { overflow:auto; }

    /* mensaje pequeño */
    .muted { color:#666; font-size:0.9rem; }

  </style>
</head>
<body>

  <header style="margin-bottom:12px;">
    <h1>Polla — Grupo</h1>
    <div class="top-actions">
      <div class="input-inline card" style="padding:8px;">
        <label for="priceInput" class="small" style="margin-right:6px;">Precio por jugador</label>
        <input id="priceInput" type="number" min="0" step="1" />
      </div>
      <button id="createBtn" class="primary">Crear / Actualizar Polla</button>
      <div id="statusMsg" class="muted"></div>
    </div>
  </header>

  <section id="saldoArea" class="card" style="display:none;">
    <div style="display:flex;justify-content:space-between;align-items:center;">
      <div>
        <div class="small">Tu saldo actual (según estado de la polla)</div>
        <div id="tuSaldo" class="saldo">Cargando...</div>
      </div>
      <div class="small">Tarjetas totales: <span id="totalTarjetas">0</span></div>
    </div>
  </section>

  <section id="tablaArea" class="card" style="display:none;">
    <div style="font-weight:800;margin-bottom:8px;">Resultados parciales — ordenados por total (con handicap)</div>
    <div class="table-wrap">
      <table id="resultsTable">
        <thead>
          <tr>
            <th class="sticky">#</th>
            <th class="sticky">Jugador</th>
            <!-- Hoyo 1..18 -->
            <!-- se insertan dinámicamente -->
            <th class="sticky">Total</th>
            <th class="sticky">Total c/ Hcp</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </section>

  <section id="debug" style="margin-top:10px; font-size:0.85rem; color:#666;"></section>

  <script>
    function getQueryParam(n){ const u=new URL(location.href); return u.searchParams.get(n); }
    function initialsFromName(nameOrEmail){
      if(!nameOrEmail) return '';
      const parts = nameOrEmail.split(/\s+/).filter(Boolean);
      if(parts.length === 0) return '';
      if(parts.length === 1){
        const p = parts[0];
        // if it's an email, take first letter before @
        const idx = p.indexOf('@');
        return (idx >= 0 ? p[0] : p[0]).toUpperCase();
      }
      return (parts[0][0] + parts[parts.length-1][0]).toUpperCase();
    }
  </script>

  <script type="module">
    import { app, db } from './firebase-config.js';
    import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";
    import {
      doc, getDoc, setDoc, updateDoc, collection, query, where, getDocs, serverTimestamp
    } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

    const juegoId = getQueryParam('juegoId') || getQueryParam('id');
    const priceInput = document.getElementById('priceInput');
    const createBtn = document.getElementById('createBtn');
    const statusMsg = document.getElementById('statusMsg');
    const saldoArea = document.getElementById('saldoArea');
    const tuSaldoEl = document.getElementById('tuSaldo');
    const totalTarjetasEl = document.getElementById('totalTarjetas');
    const tablaArea = document.getElementById('tablaArea');
    const resultsTableBody = document.querySelector('#resultsTable tbody');
    const debugEl = document.getElementById('debug');

    if (!juegoId) {
      document.body.innerHTML = '<div style="color:#b33;padding:18px;">Falta parámetro juegoId en la URL</div>';
      throw new Error('Falta juegoId');
    }

    const authInst = getAuth(app);
    let currentUser = null;

    // referencia al doc de la polla: colección 'juego_polla', id = juegoId
    const pollaRef = (id) => doc(db, 'juego_polla', id);

    // crea o actualiza el documento de polla con pricePerPlayer
    async function crearOActualizarPolla(price) {
      try {
        const pref = pollaRef(juegoId);
        const snap = await getDoc(pref);
        if (!snap.exists()) {
          await setDoc(pref, {
            juegoId,
            pricePerPlayer: price,
            createdAt: serverTimestamp(),
            updatedAt: serverTimestamp()
          });
          statusMsg.textContent = 'Polla creada.';
        } else {
          await updateDoc(pref, {
            pricePerPlayer: price,
            updatedAt: serverTimestamp()
          });
          statusMsg.textContent = 'Polla actualizada.';
        }
        await recalcAndRender(); // recalcula inmediatamente
      } catch (err) {
        console.error('Error creando/actualizando polla', err);
        statusMsg.textContent = 'Error al crear/actualizar polla. Revisa consola.';
      }
    }

    // cargar valor existente de polla (si existe) y mostrar en input
    async function loadPollaIfExists() {
      try {
        const pref = pollaRef(juegoId);
        const snap = await getDoc(pref);
        if (snap.exists()) {
          const data = snap.data();
          if (typeof data.pricePerPlayer === 'number') {
            priceInput.value = data.pricePerPlayer;
            statusMsg.textContent = 'Polla cargada.';
          }
        } else {
          statusMsg.textContent = 'No existe polla para este juego. Define un precio y haz Crear.';
        }
      } catch (err) {
        console.error('Error cargando polla', err);
      }
    }

    // función para obtener tarjetas del juego con al menos un score registrado
    async function fetchTarjetasConScores() {
      const tarjetas = [];
      try {
        const tarjetasCol = collection(db, 'tarjetas');
        const q = query(tarjetasCol, where('juegoId', '==', juegoId));
        const snap = await getDocs(q);
        for (const d of snap.docs) {
          const t = { id: d.id, ...d.data() };
          // consideramos "tiene hoyos" si scores existe y hay al menos un objeto con 'golpes' numérico
          if (Array.isArray(t.scores) && t.scores.some(s => typeof s.golpes === 'number')) {
            tarjetas.push(t);
          }
        }
      } catch (err) {
        console.error('Error trayendo tarjetas', err);
      }
      return tarjetas;
    }

    // obtiene datos de usuario por uid (handicap + nombre)
    const userCache = new Map();
    async function getUser(uid) {
      if (!uid) return null;
      if (userCache.has(uid)) return userCache.get(uid);
      try {
        const uref = doc(db, 'users', uid);
        const usnap = await getDoc(uref);
        if (usnap.exists()) {
          const udata = usnap.data();
          userCache.set(uid, { uid, ...udata });
          return userCache.get(uid);
        } else {
          userCache.set(uid, { uid });
          return userCache.get(uid);
        }
      } catch (err) {
        console.error('Error fetching user', uid, err);
        userCache.set(uid, { uid });
        return userCache.get(uid);
      }
    }

    // obtiene campo de golf (pares por hoyo)
    const campoCache = new Map();
    async function getCampo(campoId) {
      if (!campoId) return null;
      if (campoCache.has(campoId)) return campoCache.get(campoId);
      try {
        const cref = doc(db, 'camposGolf', campoId);
        const csnap = await getDoc(cref);
        if (csnap.exists()) {
          const cdata = csnap.data();
          campoCache.set(campoId, cdata);
          return cdata;
        } else {
          campoCache.set(campoId, null);
          return null;
        }
      } catch (err) {
        console.error('Error fetching campo', campoId, err);
        campoCache.set(campoId, null);
        return null;
      }
    }

    // convierte array scores a map por hoyo (1..18)
    function scoresToMap(scoresArray) {
      const m = new Map();
      if (!Array.isArray(scoresArray)) return m;
      for (const s of scoresArray) {
        if (s && typeof s.hoyo === 'number' && typeof s.golpes === 'number') {
          m.set(s.hoyo, s.golpes);
        }
      }
      return m;
    }

    // calcula totales y construye standings
    async function buildStandings(tarjetas, pricePerPlayer) {
      const standings = [];
      for (const t of tarjetas) {
        const userUid = t.userUid;
        const user = await getUser(userUid);
        const nombre = user?.name || user?.nombre || user?.firstName || user?.email || userUid || 'Jugador';
        const handicap = Number(user?.handicap ?? user?.hcp ?? 0) || 0;

        // campo para colores
        const campo = await getCampo(t.campoId);

        const scoreMap = scoresToMap(t.scores || []);
        // total sin handicap: suma de golpes en los hoyos que existan
        let total = 0;
        for (const [h, g] of scoreMap.entries()) total += g;
        const totalConHcp = total - handicap;

        // construir arreglo de 18 valores (null si no hay)
        const holes = [];
        for (let i = 1; i <= 18; i++) {
          const g = scoreMap.has(i) ? scoreMap.get(i) : null;
          // par correspondiente si existe
          const par = Array.isArray(campo?.paresHoyo) ? Number(campo.paresHoyo[i-1]) : null;
          holes.push({ golpe: g, par });
        }

        standings.push({
          tarjetaId: t.id,
          userUid,
          nombre,
          handicap,
          total,
          totalConHcp,
          holes
        });
      }

      // ordenar por totalConHcp asc (el menor gana)
      standings.sort((a,b) => {
        // if tie, fallback to total
        if (a.totalConHcp === b.totalConHcp) return a.total - b.total;
        return a.totalConHcp - b.totalConHcp;
      });

      // asignar posiciones consecutivas (1,2,3...)
      for (let i = 0; i < standings.length; i++) {
        standings[i].pos = i+1;
      }

      return standings;
    }

    // render tabla y saldo del usuario actual
    async function render(standings, pricePerPlayer) {
      // mostrar contenedores
      tablaArea.style.display = 'block';
      saldoArea.style.display = 'block';

      resultsTableBody.innerHTML = '';

      // encabezados de hoyos (insertar despues del header existente)
      const theadRow = document.querySelector('#resultsTable thead tr');
      // limpiar posibles encabezados de hoyos previos
      // dejamos los primeros 2 (pos y jugador) y los últimos 2 (Total, Total c/ Hcp)
      // así que eliminamos lo que haya en medio antes de reinsertar
      while (theadRow.children.length > 4) theadRow.removeChild(theadRow.children[2]);

      for (let i = 1; i <= 18; i++) {
        const th = document.createElement('th');
        th.textContent = 'H' + i;
        theadRow.insertBefore(th, theadRow.children[theadRow.children.length - 2]);
      }

      // totals
      totalTarjetasEl.textContent = standings.length;

      // identificar lider actual (posición 1 si existe)
      const lider = standings[0] || null;

      // calcular saldo para el usuario actual
      let tuSaldo = 0;
      if (currentUser) {
        const tuTarjeta = standings.find(s => s.userUid === currentUser.uid);
        const n = standings.length;
        if (tuTarjeta) {
          // si eres lider => te llevas (n * price) - price = price*(n-1)
          if (tuTarjeta.pos === 1) {
            tuSaldo = (n * pricePerPlayer) - pricePerPlayer;
          } else {
            // no eres lider: pagaste tu cuota (negativo)
            tuSaldo = -pricePerPlayer;
          }
        } else {
          // si no tienes tarjeta incluida: tu saldo es -price (si quieres participar pero no has cargado tarjeta)
          tuSaldo = -pricePerPlayer;
        }
      } else {
        tuSaldo = 0;
      }

      tuSaldoEl.textContent = (tuSaldo >= 0 ? '+ ' : '') + tuSaldo + ' MXN';

      // construir filas
      for (const s of standings) {
        const tr = document.createElement('tr');

        // posición
        const tdPos = document.createElement('td');
        tdPos.textContent = s.pos;
        tr.appendChild(tdPos);

        // jugador - avatar + nombre
        const tdUser = document.createElement('td');
        tdUser.className = 'user-cell';
        const av = document.createElement('div');
        av.className = 'avatar';
        av.textContent = initialsFromName(s.nombre);
        const nameDiv = document.createElement('div');
        nameDiv.style.textAlign = 'left';
        nameDiv.innerHTML = `<div style="font-weight:700;">${s.nombre}</div><div class="small">Hcp: ${s.handicap}</div>`;
        tdUser.appendChild(av);
        tdUser.appendChild(nameDiv);
        tr.appendChild(tdUser);

        // hoyos 1..18
        for (let i = 0; i < 18; i++) {
          const hole = s.holes[i];
          const td = document.createElement('td');
          const g = hole.golpe;
          const par = hole.par;
          if (g === null || typeof g === 'undefined') {
            td.textContent = '-';
          } else {
            td.textContent = g;
            // colorear según comparación con par si par existe (par es número)
            if (typeof par === 'number' && !isNaN(par)) {
              if (g < par) td.classList.add('hole-below');
              else if (g === par) td.classList.add('hole-par');
              else td.classList.add('hole-above');
            }
          }
          tr.appendChild(td);
        }

        // total sin handicap
        const tdTotal = document.createElement('td');
        tdTotal.className = 'totals';
        tdTotal.textContent = s.total;
        tr.appendChild(tdTotal);

        // total con handicap
        const tdTotalH = document.createElement('td');
        tdTotalH.className = 'totals';
        tdTotalH.textContent = s.totalConHcp;
        tr.appendChild(tdTotalH);

        resultsTableBody.appendChild(tr);
      }
    }

    // recalcula standings, renderiza y guarda snapshot en juego_polla
    async function recalcAndRender() {
      try {
        statusMsg.textContent = 'Calculando...';
        // obtener price de doc polla
        const pref = pollaRef(juegoId);
        const psnap = await getDoc(pref);
        let price = Number(priceInput.value || 0);
        if (psnap.exists()) {
          const pdata = psnap.data();
          if (typeof pdata.pricePerPlayer === 'number' && !isNaN(pdata.pricePerPlayer)) {
            // si el input está vacío usamos el guardado
            if (!price) price = pdata.pricePerPlayer;
            priceInput.value = pdata.pricePerPlayer;
          }
        }

        // si no hay price definido no seguimos (pero permitimos ver tarjetas)
        const tarjetas = await fetchTarjetasConScores();
        if (tarjetas.length === 0) {
          tablaArea.style.display = 'none';
          saldoArea.style.display = 'block';
          totalTarjetasEl.textContent = '0';
          tuSaldoEl.textContent = '0 MXN';
          statusMsg.textContent = 'No hay tarjetas con hoyos registrados aún.';
          // actualizar polla doc con empty snapshot
          await setDoc(pref, {
            juegoId,
            pricePerPlayer: price || 0,
            updatedAt: serverTimestamp(),
            standings: [],
            snapshotCount: 0
          }, { merge: true });
          return;
        }

        const standings = await buildStandings(tarjetas, price || 0);
        await render(standings, price || 0);

        // guardar snapshot en juego_polla/{juegoId}
        const toSave = {
          juegoId,
          pricePerPlayer: price || 0,
          updatedAt: serverTimestamp(),
          snapshotCount: standings.length,
          standings: standings.map(s => ({
            tarjetaId: s.tarjetaId,
            userUid: s.userUid,
            nombre: s.nombre,
            handicap: s.handicap,
            total: s.total,
            totalConHcp: s.totalConHcp,
            pos: s.pos
            // no guardamos todos los hoyos para ahorrar espacio; si quieres guardarlos, descomenta abajo:
            // holes: s.holes
          }))
        };
        await setDoc(pref, toSave, { merge: true });

        statusMsg.textContent = 'Actualizado.';
      } catch (err) {
        console.error('Error en recalcAndRender', err);
        statusMsg.textContent = 'Error calculando resultados. Revisa consola.';
      }
    }

    // eventos UI
    createBtn.addEventListener('click', async () => {
      const price = Number(priceInput.value || 0);
      if (!price || price <= 0) {
        alert('Ingresa un precio válido mayor que 0');
        return;
      }
      await crearOActualizarPolla(price);
    });

    // init
    onAuthStateChanged(authInst, async (user) => {
      currentUser = user;
      // cargar polla si existe
      await loadPollaIfExists();
      // siempre recalcular y renderizar al entrar
      await recalcAndRender();
      // opcional: refrescar cada X segundos para mantener datos actualizados
      // Comentado por defecto; descomenta si quieres auto-refresh:
      // setInterval(recalcAndRender, 30_000);
    });

  </script>
</body>
</html>
